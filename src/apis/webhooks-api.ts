/* tslint:disable */
/* eslint-disable */
/**
 * Zeplin API
 * Access your resources in Zeplin
 *
 * Contact: support@zeplin.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosResponse } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import {
    EntityReference,
    transformEntityReferenceToJSON,
    transformJSONToEntityReference
} from '../models';
// @ts-ignore
import {
    ErrorResponse,
    transformErrorResponseToJSON,
    transformJSONToErrorResponse
} from '../models';
// @ts-ignore
import {
    OrganizationWebhook,
    transformOrganizationWebhookToJSON,
    transformJSONToOrganizationWebhook
} from '../models';
// @ts-ignore
import {
    OrganizationWebhookCreateBody,
    transformOrganizationWebhookCreateBodyToJSON,
    transformJSONToOrganizationWebhookCreateBody
} from '../models';
// @ts-ignore
import {
    OrganizationWebhookUpdateBody,
    transformOrganizationWebhookUpdateBodyToJSON,
    transformJSONToOrganizationWebhookUpdateBody
} from '../models';
// @ts-ignore
import {
    ProjectWebhook,
    transformProjectWebhookToJSON,
    transformJSONToProjectWebhook
} from '../models';
// @ts-ignore
import {
    ProjectWebhookCreateBody,
    transformProjectWebhookCreateBodyToJSON,
    transformJSONToProjectWebhookCreateBody
} from '../models';
// @ts-ignore
import {
    ProjectWebhookUpdateBody,
    transformProjectWebhookUpdateBodyToJSON,
    transformJSONToProjectWebhookUpdateBody
} from '../models';
// @ts-ignore
import {
    StyleguideWebhook,
    transformStyleguideWebhookToJSON,
    transformJSONToStyleguideWebhook
} from '../models';
// @ts-ignore
import {
    StyleguideWebhookCreateBody,
    transformStyleguideWebhookCreateBodyToJSON,
    transformJSONToStyleguideWebhookCreateBody
} from '../models';
// @ts-ignore
import {
    StyleguideWebhookUpdateBody,
    transformStyleguideWebhookUpdateBodyToJSON,
    transformJSONToStyleguideWebhookUpdateBody
} from '../models';
// @ts-ignore
import {
    UserWebhook,
    transformUserWebhookToJSON,
    transformJSONToUserWebhook
} from '../models';
// @ts-ignore
import {
    UserWebhookCreateBody,
    transformUserWebhookCreateBodyToJSON,
    transformJSONToUserWebhookCreateBody
} from '../models';
// @ts-ignore
import {
    UserWebhookUpdateBody,
    transformUserWebhookUpdateBodyToJSON,
    transformJSONToUserWebhookUpdateBody
} from '../models';
// @ts-ignore
import {
    WebhookHealthEnum,
    transformWebhookHealthEnumToJSON,
    transformJSONToWebhookHealthEnum
} from '../models';
// @ts-ignore
import {
    WebhookStatusEnum,
    transformWebhookStatusEnumToJSON,
    transformJSONToWebhookStatusEnum
} from '../models';
/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a webhook for the organization  Wildcard `\"*\"` can be used for `project_ids` and `styleguide_ids` to receive events for all projects and styleguides that you own. You\'ll also automatically subscribe to the new ones you create in the future.  Note: Users that have authorized the app before webhooks release must re-authorize the app to create webhooks. 
         * @summary Create organization webhooks
         * @param {string} organizationId Organization id
         * @param {OrganizationWebhookCreateBody} organizationWebhookCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationWebhooks: async (organizationId: string, organizationWebhookCreateBody: OrganizationWebhookCreateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationWebhooks', 'organizationId', organizationId)
            // verify required parameter 'organizationWebhookCreateBody' is not null or undefined
            assertParamExists('createOrganizationWebhooks', 'organizationWebhookCreateBody', organizationWebhookCreateBody)
            const localVarPath = `/v1/organizations/{organization_id}/webhooks`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformOrganizationWebhookCreateBodyToJSON(organizationWebhookCreateBody), localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a webhook for the project  Note: Users that have authorized the app before webhooks release must re-authorize the app to create webhooks. 
         * @summary Create project webhooks
         * @param {string} projectId Project id
         * @param {ProjectWebhookCreateBody} projectWebhookCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectWebhooks: async (projectId: string, projectWebhookCreateBody: ProjectWebhookCreateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectWebhooks', 'projectId', projectId)
            // verify required parameter 'projectWebhookCreateBody' is not null or undefined
            assertParamExists('createProjectWebhooks', 'projectWebhookCreateBody', projectWebhookCreateBody)
            const localVarPath = `/v1/projects/{project_id}/webhooks`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformProjectWebhookCreateBodyToJSON(projectWebhookCreateBody), localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a webhook for the styleguide  Note: Users that have authorized the app before webhooks release must re-authorize the app to create webhooks. 
         * @summary Create styleguide webhooks
         * @param {string} styleguideId Styleguide id
         * @param {StyleguideWebhookCreateBody} styleguideWebhookCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStyleguideWebhooks: async (styleguideId: string, styleguideWebhookCreateBody: StyleguideWebhookCreateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'styleguideId' is not null or undefined
            assertParamExists('createStyleguideWebhooks', 'styleguideId', styleguideId)
            // verify required parameter 'styleguideWebhookCreateBody' is not null or undefined
            assertParamExists('createStyleguideWebhooks', 'styleguideWebhookCreateBody', styleguideWebhookCreateBody)
            const localVarPath = `/v1/styleguides/{styleguide_id}/webhooks`
                .replace(`{${"styleguide_id"}}`, encodeURIComponent(String(styleguideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformStyleguideWebhookCreateBodyToJSON(styleguideWebhookCreateBody), localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a webhook for the user  Wildcard `\"*\"` can be used for `project_ids` and `styleguide_ids` to receive events for all projects and styleguides that you own. You\'ll also automatically subscribe to the new ones you create in the future.  Note: Users that have authorized the app before webhooks release must re-authorize the app to create webhooks. 
         * @summary Create user webhooks
         * @param {UserWebhookCreateBody} userWebhookCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWebhooks: async (userWebhookCreateBody: UserWebhookCreateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userWebhookCreateBody' is not null or undefined
            assertParamExists('createUserWebhooks', 'userWebhookCreateBody', userWebhookCreateBody)
            const localVarPath = `/v1/users/me/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformUserWebhookCreateBodyToJSON(userWebhookCreateBody), localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook by id
         * @summary Delete a webhook of an organization
         * @param {string} organizationId Organization id
         * @param {string} webhookId Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationWebhook: async (organizationId: string, webhookId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationWebhook', 'organizationId', organizationId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteOrganizationWebhook', 'webhookId', webhookId)
            const localVarPath = `/v1/organizations/{organization_id}/webhooks/{webhook_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook by id
         * @summary Delete a webhook of a project
         * @param {string} projectId Project id
         * @param {string} webhookId Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectWebhook: async (projectId: string, webhookId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectWebhook', 'projectId', projectId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteProjectWebhook', 'webhookId', webhookId)
            const localVarPath = `/v1/projects/{project_id}/webhooks/{webhook_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook by id
         * @summary Delete a webhook of a styleguide
         * @param {string} styleguideId Styleguide id
         * @param {string} webhookId Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStyleguideWebhook: async (styleguideId: string, webhookId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'styleguideId' is not null or undefined
            assertParamExists('deleteStyleguideWebhook', 'styleguideId', styleguideId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteStyleguideWebhook', 'webhookId', webhookId)
            const localVarPath = `/v1/styleguides/{styleguide_id}/webhooks/{webhook_id}`
                .replace(`{${"styleguide_id"}}`, encodeURIComponent(String(styleguideId)))
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook by id
         * @summary Delete a webhook of a user
         * @param {string} webhookId Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserWebhook: async (webhookId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteUserWebhook', 'webhookId', webhookId)
            const localVarPath = `/v1/users/me/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a webhook by id
         * @summary Get a webhook of organization
         * @param {string} organizationId Organization id
         * @param {string} webhookId Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationWebhook: async (organizationId: string, webhookId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationWebhook', 'organizationId', organizationId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getOrganizationWebhook', 'webhookId', webhookId)
            const localVarPath = `/v1/organizations/{organization_id}/webhooks/{webhook_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all webhooks of organization  Note: Zeplin apps can only list the webhook that are created by them. To list all webhooks created by any app or without app, personal access token is needed. 
         * @summary Get organization webhooks
         * @param {string} organizationId Organization id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {WebhookStatusEnum} [status] Filter by webhook status
         * @param {WebhookHealthEnum} [urlHealth] Filter by health of webhook\&#39;s URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationWebhooks: async (organizationId: string, limit?: number, offset?: number, status?: WebhookStatusEnum, urlHealth?: WebhookHealthEnum, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationWebhooks', 'organizationId', organizationId)
            const localVarPath = `/v1/organizations/{organization_id}/webhooks`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (urlHealth !== undefined) {
                localVarQueryParameter['url_health'] = urlHealth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a webhook by id
         * @summary Get a webhook of project
         * @param {string} projectId Project id
         * @param {string} webhookId Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectWebhook: async (projectId: string, webhookId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectWebhook', 'projectId', projectId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getProjectWebhook', 'webhookId', webhookId)
            const localVarPath = `/v1/projects/{project_id}/webhooks/{webhook_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all webhooks of the project  Note: Zeplin apps can only list the webhook that are created by them. To list all webhooks created by any app or without app, personal access token is needed. 
         * @summary Get project webhooks
         * @param {string} projectId Project id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {WebhookStatusEnum} [status] Filter by webhook status
         * @param {WebhookHealthEnum} [urlHealth] Filter by health of webhook\&#39;s URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectWebhooks: async (projectId: string, limit?: number, offset?: number, status?: WebhookStatusEnum, urlHealth?: WebhookHealthEnum, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectWebhooks', 'projectId', projectId)
            const localVarPath = `/v1/projects/{project_id}/webhooks`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (urlHealth !== undefined) {
                localVarQueryParameter['url_health'] = urlHealth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a webhook by id
         * @summary Get a webhook of styleguide
         * @param {string} styleguideId Styleguide id
         * @param {string} webhookId Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStyleguideWebhook: async (styleguideId: string, webhookId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'styleguideId' is not null or undefined
            assertParamExists('getStyleguideWebhook', 'styleguideId', styleguideId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getStyleguideWebhook', 'webhookId', webhookId)
            const localVarPath = `/v1/styleguides/{styleguide_id}/webhooks/{webhook_id}`
                .replace(`{${"styleguide_id"}}`, encodeURIComponent(String(styleguideId)))
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all webhooks of the styleguide  Note: Zeplin apps can only list the webhook that are created by them. To list all webhooks created by any app or without app, personal access token is needed. 
         * @summary Get styleguide webhooks
         * @param {string} styleguideId Styleguide id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {WebhookStatusEnum} [status] Filter by webhook status
         * @param {WebhookHealthEnum} [urlHealth] Filter by health of webhook\&#39;s URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStyleguideWebhooks: async (styleguideId: string, limit?: number, offset?: number, status?: WebhookStatusEnum, urlHealth?: WebhookHealthEnum, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'styleguideId' is not null or undefined
            assertParamExists('getStyleguideWebhooks', 'styleguideId', styleguideId)
            const localVarPath = `/v1/styleguides/{styleguide_id}/webhooks`
                .replace(`{${"styleguide_id"}}`, encodeURIComponent(String(styleguideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (urlHealth !== undefined) {
                localVarQueryParameter['url_health'] = urlHealth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a webhook by id
         * @summary Get a webhook of user
         * @param {string} webhookId Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWebhook: async (webhookId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getUserWebhook', 'webhookId', webhookId)
            const localVarPath = `/v1/users/me/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all webhooks of the user  Note: Zeplin apps can only list the webhook that are created by them. To list all webhooks created by any app or without app, personal access token is needed. 
         * @summary Get user webhooks
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {WebhookStatusEnum} [status] Filter by webhook status
         * @param {WebhookHealthEnum} [urlHealth] Filter by health of webhook\&#39;s URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWebhooks: async (limit?: number, offset?: number, status?: WebhookStatusEnum, urlHealth?: WebhookHealthEnum, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/me/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (urlHealth !== undefined) {
                localVarQueryParameter['url_health'] = urlHealth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a webhook for the organization
         * @summary Update organization webhooks
         * @param {string} organizationId Organization id
         * @param {string} webhookId Webhook id
         * @param {OrganizationWebhookUpdateBody} organizationWebhookUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationWebhooks: async (organizationId: string, webhookId: string, organizationWebhookUpdateBody: OrganizationWebhookUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationWebhooks', 'organizationId', organizationId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateOrganizationWebhooks', 'webhookId', webhookId)
            // verify required parameter 'organizationWebhookUpdateBody' is not null or undefined
            assertParamExists('updateOrganizationWebhooks', 'organizationWebhookUpdateBody', organizationWebhookUpdateBody)
            const localVarPath = `/v1/organizations/{organization_id}/webhooks/{webhook_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformOrganizationWebhookUpdateBodyToJSON(organizationWebhookUpdateBody), localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a webhook for the project
         * @summary Update project webhooks
         * @param {string} projectId Project id
         * @param {string} webhookId Webhook id
         * @param {ProjectWebhookUpdateBody} projectWebhookUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectWebhooks: async (projectId: string, webhookId: string, projectWebhookUpdateBody: ProjectWebhookUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProjectWebhooks', 'projectId', projectId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateProjectWebhooks', 'webhookId', webhookId)
            // verify required parameter 'projectWebhookUpdateBody' is not null or undefined
            assertParamExists('updateProjectWebhooks', 'projectWebhookUpdateBody', projectWebhookUpdateBody)
            const localVarPath = `/v1/projects/{project_id}/webhooks/{webhook_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformProjectWebhookUpdateBodyToJSON(projectWebhookUpdateBody), localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a webhook for the styleguide
         * @summary Update styleguide webhooks
         * @param {string} styleguideId Styleguide id
         * @param {string} webhookId Webhook id
         * @param {StyleguideWebhookUpdateBody} styleguideWebhookUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStyleguideWebhooks: async (styleguideId: string, webhookId: string, styleguideWebhookUpdateBody: StyleguideWebhookUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'styleguideId' is not null or undefined
            assertParamExists('updateStyleguideWebhooks', 'styleguideId', styleguideId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateStyleguideWebhooks', 'webhookId', webhookId)
            // verify required parameter 'styleguideWebhookUpdateBody' is not null or undefined
            assertParamExists('updateStyleguideWebhooks', 'styleguideWebhookUpdateBody', styleguideWebhookUpdateBody)
            const localVarPath = `/v1/styleguides/{styleguide_id}/webhooks/{webhook_id}`
                .replace(`{${"styleguide_id"}}`, encodeURIComponent(String(styleguideId)))
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformStyleguideWebhookUpdateBodyToJSON(styleguideWebhookUpdateBody), localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a webhook for the user
         * @summary Update user webhooks
         * @param {string} webhookId Webhook id
         * @param {UserWebhookUpdateBody} userWebhookUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserWebhooks: async (webhookId: string, userWebhookUpdateBody: UserWebhookUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateUserWebhooks', 'webhookId', webhookId)
            // verify required parameter 'userWebhookUpdateBody' is not null or undefined
            assertParamExists('updateUserWebhooks', 'userWebhookUpdateBody', userWebhookUpdateBody)
            const localVarPath = `/v1/users/me/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformUserWebhookUpdateBodyToJSON(userWebhookUpdateBody), localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a webhook for the organization  Wildcard `\"*\"` can be used for `project_ids` and `styleguide_ids` to receive events for all projects and styleguides that you own. You\'ll also automatically subscribe to the new ones you create in the future.  Note: Users that have authorized the app before webhooks release must re-authorize the app to create webhooks. 
         * @summary Create organization webhooks
         * @param {string} organizationId Organization id
         * @param {OrganizationWebhookCreateBody} organizationWebhookCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationWebhooks(organizationId: string, organizationWebhookCreateBody: OrganizationWebhookCreateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationWebhooks(organizationId, organizationWebhookCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a webhook for the project  Note: Users that have authorized the app before webhooks release must re-authorize the app to create webhooks. 
         * @summary Create project webhooks
         * @param {string} projectId Project id
         * @param {ProjectWebhookCreateBody} projectWebhookCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectWebhooks(projectId: string, projectWebhookCreateBody: ProjectWebhookCreateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectWebhooks(projectId, projectWebhookCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a webhook for the styleguide  Note: Users that have authorized the app before webhooks release must re-authorize the app to create webhooks. 
         * @summary Create styleguide webhooks
         * @param {string} styleguideId Styleguide id
         * @param {StyleguideWebhookCreateBody} styleguideWebhookCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStyleguideWebhooks(styleguideId: string, styleguideWebhookCreateBody: StyleguideWebhookCreateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStyleguideWebhooks(styleguideId, styleguideWebhookCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a webhook for the user  Wildcard `\"*\"` can be used for `project_ids` and `styleguide_ids` to receive events for all projects and styleguides that you own. You\'ll also automatically subscribe to the new ones you create in the future.  Note: Users that have authorized the app before webhooks release must re-authorize the app to create webhooks. 
         * @summary Create user webhooks
         * @param {UserWebhookCreateBody} userWebhookCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserWebhooks(userWebhookCreateBody: UserWebhookCreateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserWebhooks(userWebhookCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a webhook by id
         * @summary Delete a webhook of an organization
         * @param {string} organizationId Organization id
         * @param {string} webhookId Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationWebhook(organizationId: string, webhookId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationWebhook(organizationId, webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a webhook by id
         * @summary Delete a webhook of a project
         * @param {string} projectId Project id
         * @param {string} webhookId Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectWebhook(projectId: string, webhookId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectWebhook(projectId, webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a webhook by id
         * @summary Delete a webhook of a styleguide
         * @param {string} styleguideId Styleguide id
         * @param {string} webhookId Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStyleguideWebhook(styleguideId: string, webhookId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStyleguideWebhook(styleguideId, webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a webhook by id
         * @summary Delete a webhook of a user
         * @param {string} webhookId Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserWebhook(webhookId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserWebhook(webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a webhook by id
         * @summary Get a webhook of organization
         * @param {string} organizationId Organization id
         * @param {string} webhookId Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationWebhook(organizationId: string, webhookId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationWebhook(organizationId, webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all webhooks of organization  Note: Zeplin apps can only list the webhook that are created by them. To list all webhooks created by any app or without app, personal access token is needed. 
         * @summary Get organization webhooks
         * @param {string} organizationId Organization id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {WebhookStatusEnum} [status] Filter by webhook status
         * @param {WebhookHealthEnum} [urlHealth] Filter by health of webhook\&#39;s URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationWebhooks(organizationId: string, limit?: number, offset?: number, status?: WebhookStatusEnum, urlHealth?: WebhookHealthEnum, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationWebhooks(organizationId, limit, offset, status, urlHealth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a webhook by id
         * @summary Get a webhook of project
         * @param {string} projectId Project id
         * @param {string} webhookId Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectWebhook(projectId: string, webhookId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectWebhook(projectId, webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all webhooks of the project  Note: Zeplin apps can only list the webhook that are created by them. To list all webhooks created by any app or without app, personal access token is needed. 
         * @summary Get project webhooks
         * @param {string} projectId Project id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {WebhookStatusEnum} [status] Filter by webhook status
         * @param {WebhookHealthEnum} [urlHealth] Filter by health of webhook\&#39;s URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectWebhooks(projectId: string, limit?: number, offset?: number, status?: WebhookStatusEnum, urlHealth?: WebhookHealthEnum, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectWebhooks(projectId, limit, offset, status, urlHealth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a webhook by id
         * @summary Get a webhook of styleguide
         * @param {string} styleguideId Styleguide id
         * @param {string} webhookId Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStyleguideWebhook(styleguideId: string, webhookId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStyleguideWebhook(styleguideId, webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all webhooks of the styleguide  Note: Zeplin apps can only list the webhook that are created by them. To list all webhooks created by any app or without app, personal access token is needed. 
         * @summary Get styleguide webhooks
         * @param {string} styleguideId Styleguide id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {WebhookStatusEnum} [status] Filter by webhook status
         * @param {WebhookHealthEnum} [urlHealth] Filter by health of webhook\&#39;s URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStyleguideWebhooks(styleguideId: string, limit?: number, offset?: number, status?: WebhookStatusEnum, urlHealth?: WebhookHealthEnum, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStyleguideWebhooks(styleguideId, limit, offset, status, urlHealth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a webhook by id
         * @summary Get a webhook of user
         * @param {string} webhookId Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWebhook(webhookId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserWebhook(webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all webhooks of the user  Note: Zeplin apps can only list the webhook that are created by them. To list all webhooks created by any app or without app, personal access token is needed. 
         * @summary Get user webhooks
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {WebhookStatusEnum} [status] Filter by webhook status
         * @param {WebhookHealthEnum} [urlHealth] Filter by health of webhook\&#39;s URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWebhooks(limit?: number, offset?: number, status?: WebhookStatusEnum, urlHealth?: WebhookHealthEnum, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserWebhooks(limit, offset, status, urlHealth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a webhook for the organization
         * @summary Update organization webhooks
         * @param {string} organizationId Organization id
         * @param {string} webhookId Webhook id
         * @param {OrganizationWebhookUpdateBody} organizationWebhookUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationWebhooks(organizationId: string, webhookId: string, organizationWebhookUpdateBody: OrganizationWebhookUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationWebhooks(organizationId, webhookId, organizationWebhookUpdateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a webhook for the project
         * @summary Update project webhooks
         * @param {string} projectId Project id
         * @param {string} webhookId Webhook id
         * @param {ProjectWebhookUpdateBody} projectWebhookUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProjectWebhooks(projectId: string, webhookId: string, projectWebhookUpdateBody: ProjectWebhookUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProjectWebhooks(projectId, webhookId, projectWebhookUpdateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a webhook for the styleguide
         * @summary Update styleguide webhooks
         * @param {string} styleguideId Styleguide id
         * @param {string} webhookId Webhook id
         * @param {StyleguideWebhookUpdateBody} styleguideWebhookUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStyleguideWebhooks(styleguideId: string, webhookId: string, styleguideWebhookUpdateBody: StyleguideWebhookUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStyleguideWebhooks(styleguideId, webhookId, styleguideWebhookUpdateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a webhook for the user
         * @summary Update user webhooks
         * @param {string} webhookId Webhook id
         * @param {UserWebhookUpdateBody} userWebhookUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserWebhooks(webhookId: string, userWebhookUpdateBody: UserWebhookUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserWebhooks(webhookId, userWebhookUpdateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};











/**
 * Search parameters for getOrganizationWebhooks operation in WebhooksApi.
 * @export
 * @interface WebhooksApiGetOrganizationWebhooksSearchParams
 */
export interface WebhooksApiGetOrganizationWebhooksSearchParams {
    /**
     * Pagination limit
     * @type {number}
     * @memberof WebhooksApiGetOrganizationWebhooksSearchParams
     */
    readonly limit?: number;

    /**
     * Pagination offset
     * @type {number}
     * @memberof WebhooksApiGetOrganizationWebhooksSearchParams
     */
    readonly offset?: number;

    /**
     * Filter by webhook status
     * @type {WebhookStatusEnum}
     * @memberof WebhooksApiGetOrganizationWebhooksSearchParams
     */
    readonly status?: WebhookStatusEnum;

    /**
     * Filter by health of webhook\&#39;s URL
     * @type {WebhookHealthEnum}
     * @memberof WebhooksApiGetOrganizationWebhooksSearchParams
     */
    readonly urlHealth?: WebhookHealthEnum;
}


/**
 * Search parameters for getProjectWebhooks operation in WebhooksApi.
 * @export
 * @interface WebhooksApiGetProjectWebhooksSearchParams
 */
export interface WebhooksApiGetProjectWebhooksSearchParams {
    /**
     * Pagination limit
     * @type {number}
     * @memberof WebhooksApiGetProjectWebhooksSearchParams
     */
    readonly limit?: number;

    /**
     * Pagination offset
     * @type {number}
     * @memberof WebhooksApiGetProjectWebhooksSearchParams
     */
    readonly offset?: number;

    /**
     * Filter by webhook status
     * @type {WebhookStatusEnum}
     * @memberof WebhooksApiGetProjectWebhooksSearchParams
     */
    readonly status?: WebhookStatusEnum;

    /**
     * Filter by health of webhook\&#39;s URL
     * @type {WebhookHealthEnum}
     * @memberof WebhooksApiGetProjectWebhooksSearchParams
     */
    readonly urlHealth?: WebhookHealthEnum;
}


/**
 * Search parameters for getStyleguideWebhooks operation in WebhooksApi.
 * @export
 * @interface WebhooksApiGetStyleguideWebhooksSearchParams
 */
export interface WebhooksApiGetStyleguideWebhooksSearchParams {
    /**
     * Pagination limit
     * @type {number}
     * @memberof WebhooksApiGetStyleguideWebhooksSearchParams
     */
    readonly limit?: number;

    /**
     * Pagination offset
     * @type {number}
     * @memberof WebhooksApiGetStyleguideWebhooksSearchParams
     */
    readonly offset?: number;

    /**
     * Filter by webhook status
     * @type {WebhookStatusEnum}
     * @memberof WebhooksApiGetStyleguideWebhooksSearchParams
     */
    readonly status?: WebhookStatusEnum;

    /**
     * Filter by health of webhook\&#39;s URL
     * @type {WebhookHealthEnum}
     * @memberof WebhooksApiGetStyleguideWebhooksSearchParams
     */
    readonly urlHealth?: WebhookHealthEnum;
}


/**
 * Search parameters for getUserWebhooks operation in WebhooksApi.
 * @export
 * @interface WebhooksApiGetUserWebhooksSearchParams
 */
export interface WebhooksApiGetUserWebhooksSearchParams {
    /**
     * Pagination limit
     * @type {number}
     * @memberof WebhooksApiGetUserWebhooksSearchParams
     */
    readonly limit?: number;

    /**
     * Pagination offset
     * @type {number}
     * @memberof WebhooksApiGetUserWebhooksSearchParams
     */
    readonly offset?: number;

    /**
     * Filter by webhook status
     * @type {WebhookStatusEnum}
     * @memberof WebhooksApiGetUserWebhooksSearchParams
     */
    readonly status?: WebhookStatusEnum;

    /**
     * Filter by health of webhook\&#39;s URL
     * @type {WebhookHealthEnum}
     * @memberof WebhooksApiGetUserWebhooksSearchParams
     */
    readonly urlHealth?: WebhookHealthEnum;
}






/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Create a webhook for the organization  Wildcard `\"*\"` can be used for `project_ids` and `styleguide_ids` to receive events for all projects and styleguides that you own. You\'ll also automatically subscribe to the new ones you create in the future.  Note: Users that have authorized the app before webhooks release must re-authorize the app to create webhooks. 
     * @summary Create organization webhooks
     * @param {string} organizationId Organization id
     * @param {OrganizationWebhookCreateBody} organizationWebhookCreateBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async createOrganizationWebhooks(organizationId: string, organizationWebhookCreateBody: OrganizationWebhookCreateBody, options?: any) : Promise<AxiosResponse<EntityReference>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.createOrganizationWebhooks(organizationId, organizationWebhookCreateBody, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToEntityReference(response.data)
        };
    }

    /**
     * Create a webhook for the project  Note: Users that have authorized the app before webhooks release must re-authorize the app to create webhooks. 
     * @summary Create project webhooks
     * @param {string} projectId Project id
     * @param {ProjectWebhookCreateBody} projectWebhookCreateBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async createProjectWebhooks(projectId: string, projectWebhookCreateBody: ProjectWebhookCreateBody, options?: any) : Promise<AxiosResponse<EntityReference>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.createProjectWebhooks(projectId, projectWebhookCreateBody, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToEntityReference(response.data)
        };
    }

    /**
     * Create a webhook for the styleguide  Note: Users that have authorized the app before webhooks release must re-authorize the app to create webhooks. 
     * @summary Create styleguide webhooks
     * @param {string} styleguideId Styleguide id
     * @param {StyleguideWebhookCreateBody} styleguideWebhookCreateBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async createStyleguideWebhooks(styleguideId: string, styleguideWebhookCreateBody: StyleguideWebhookCreateBody, options?: any) : Promise<AxiosResponse<EntityReference>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.createStyleguideWebhooks(styleguideId, styleguideWebhookCreateBody, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToEntityReference(response.data)
        };
    }

    /**
     * Create a webhook for the user  Wildcard `\"*\"` can be used for `project_ids` and `styleguide_ids` to receive events for all projects and styleguides that you own. You\'ll also automatically subscribe to the new ones you create in the future.  Note: Users that have authorized the app before webhooks release must re-authorize the app to create webhooks. 
     * @summary Create user webhooks
     * @param {UserWebhookCreateBody} userWebhookCreateBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async createUserWebhooks(userWebhookCreateBody: UserWebhookCreateBody, options?: any) : Promise<AxiosResponse<EntityReference>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.createUserWebhooks(userWebhookCreateBody, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToEntityReference(response.data)
        };
    }

    /**
     * Delete a webhook by id
     * @summary Delete a webhook of an organization
     * @param {string} organizationId Organization id
     * @param {string} webhookId Webhook id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async deleteOrganizationWebhook(organizationId: string, webhookId: string, options?: any) : Promise<AxiosResponse<void>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.deleteOrganizationWebhook(organizationId, webhookId, options);
        const response = await request(this.axios, this.basePath);
        return response;
    }

    /**
     * Delete a webhook by id
     * @summary Delete a webhook of a project
     * @param {string} projectId Project id
     * @param {string} webhookId Webhook id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async deleteProjectWebhook(projectId: string, webhookId: string, options?: any) : Promise<AxiosResponse<void>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.deleteProjectWebhook(projectId, webhookId, options);
        const response = await request(this.axios, this.basePath);
        return response;
    }

    /**
     * Delete a webhook by id
     * @summary Delete a webhook of a styleguide
     * @param {string} styleguideId Styleguide id
     * @param {string} webhookId Webhook id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async deleteStyleguideWebhook(styleguideId: string, webhookId: string, options?: any) : Promise<AxiosResponse<void>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.deleteStyleguideWebhook(styleguideId, webhookId, options);
        const response = await request(this.axios, this.basePath);
        return response;
    }

    /**
     * Delete a webhook by id
     * @summary Delete a webhook of a user
     * @param {string} webhookId Webhook id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async deleteUserWebhook(webhookId: string, options?: any) : Promise<AxiosResponse<void>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.deleteUserWebhook(webhookId, options);
        const response = await request(this.axios, this.basePath);
        return response;
    }

    /**
     * Get a webhook by id
     * @summary Get a webhook of organization
     * @param {string} organizationId Organization id
     * @param {string} webhookId Webhook id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async getOrganizationWebhook(organizationId: string, webhookId: string, options?: any) : Promise<AxiosResponse<OrganizationWebhook>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.getOrganizationWebhook(organizationId, webhookId, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToOrganizationWebhook(response.data)
        };
    }

    /**
     * List all webhooks of organization  Note: Zeplin apps can only list the webhook that are created by them. To list all webhooks created by any app or without app, personal access token is needed. 
     * @summary Get organization webhooks
     * @param {string} organizationId Organization id
     * @param {WebhooksApiGetOrganizationWebhooksSearchParams} [searchParams] Search parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async getOrganizationWebhooks(organizationId: string, searchParams: WebhooksApiGetOrganizationWebhooksSearchParams = {}, options?: any) : Promise<AxiosResponse<Array<OrganizationWebhook>>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.getOrganizationWebhooks(organizationId, searchParams.limit, searchParams.offset, searchParams.status, searchParams.urlHealth, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: response.data.map(transformJSONToOrganizationWebhook)
        };
    }

    /**
     * Get a webhook by id
     * @summary Get a webhook of project
     * @param {string} projectId Project id
     * @param {string} webhookId Webhook id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async getProjectWebhook(projectId: string, webhookId: string, options?: any) : Promise<AxiosResponse<ProjectWebhook>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.getProjectWebhook(projectId, webhookId, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToProjectWebhook(response.data)
        };
    }

    /**
     * List all webhooks of the project  Note: Zeplin apps can only list the webhook that are created by them. To list all webhooks created by any app or without app, personal access token is needed. 
     * @summary Get project webhooks
     * @param {string} projectId Project id
     * @param {WebhooksApiGetProjectWebhooksSearchParams} [searchParams] Search parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async getProjectWebhooks(projectId: string, searchParams: WebhooksApiGetProjectWebhooksSearchParams = {}, options?: any) : Promise<AxiosResponse<Array<ProjectWebhook>>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.getProjectWebhooks(projectId, searchParams.limit, searchParams.offset, searchParams.status, searchParams.urlHealth, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: response.data.map(transformJSONToProjectWebhook)
        };
    }

    /**
     * Get a webhook by id
     * @summary Get a webhook of styleguide
     * @param {string} styleguideId Styleguide id
     * @param {string} webhookId Webhook id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async getStyleguideWebhook(styleguideId: string, webhookId: string, options?: any) : Promise<AxiosResponse<StyleguideWebhook>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.getStyleguideWebhook(styleguideId, webhookId, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToStyleguideWebhook(response.data)
        };
    }

    /**
     * List all webhooks of the styleguide  Note: Zeplin apps can only list the webhook that are created by them. To list all webhooks created by any app or without app, personal access token is needed. 
     * @summary Get styleguide webhooks
     * @param {string} styleguideId Styleguide id
     * @param {WebhooksApiGetStyleguideWebhooksSearchParams} [searchParams] Search parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async getStyleguideWebhooks(styleguideId: string, searchParams: WebhooksApiGetStyleguideWebhooksSearchParams = {}, options?: any) : Promise<AxiosResponse<Array<StyleguideWebhook>>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.getStyleguideWebhooks(styleguideId, searchParams.limit, searchParams.offset, searchParams.status, searchParams.urlHealth, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: response.data.map(transformJSONToStyleguideWebhook)
        };
    }

    /**
     * Get a webhook by id
     * @summary Get a webhook of user
     * @param {string} webhookId Webhook id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async getUserWebhook(webhookId: string, options?: any) : Promise<AxiosResponse<UserWebhook>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.getUserWebhook(webhookId, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToUserWebhook(response.data)
        };
    }

    /**
     * List all webhooks of the user  Note: Zeplin apps can only list the webhook that are created by them. To list all webhooks created by any app or without app, personal access token is needed. 
     * @summary Get user webhooks
     * @param {WebhooksApiGetUserWebhooksSearchParams} [searchParams] Search parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async getUserWebhooks(searchParams: WebhooksApiGetUserWebhooksSearchParams = {}, options?: any) : Promise<AxiosResponse<Array<UserWebhook>>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.getUserWebhooks(searchParams.limit, searchParams.offset, searchParams.status, searchParams.urlHealth, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: response.data.map(transformJSONToUserWebhook)
        };
    }

    /**
     * Update a webhook for the organization
     * @summary Update organization webhooks
     * @param {string} organizationId Organization id
     * @param {string} webhookId Webhook id
     * @param {OrganizationWebhookUpdateBody} organizationWebhookUpdateBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async updateOrganizationWebhooks(organizationId: string, webhookId: string, organizationWebhookUpdateBody: OrganizationWebhookUpdateBody, options?: any) : Promise<AxiosResponse<void>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.updateOrganizationWebhooks(organizationId, webhookId, organizationWebhookUpdateBody, options);
        const response = await request(this.axios, this.basePath);
        return response;
    }

    /**
     * Update a webhook for the project
     * @summary Update project webhooks
     * @param {string} projectId Project id
     * @param {string} webhookId Webhook id
     * @param {ProjectWebhookUpdateBody} projectWebhookUpdateBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async updateProjectWebhooks(projectId: string, webhookId: string, projectWebhookUpdateBody: ProjectWebhookUpdateBody, options?: any) : Promise<AxiosResponse<void>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.updateProjectWebhooks(projectId, webhookId, projectWebhookUpdateBody, options);
        const response = await request(this.axios, this.basePath);
        return response;
    }

    /**
     * Update a webhook for the styleguide
     * @summary Update styleguide webhooks
     * @param {string} styleguideId Styleguide id
     * @param {string} webhookId Webhook id
     * @param {StyleguideWebhookUpdateBody} styleguideWebhookUpdateBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async updateStyleguideWebhooks(styleguideId: string, webhookId: string, styleguideWebhookUpdateBody: StyleguideWebhookUpdateBody, options?: any) : Promise<AxiosResponse<void>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.updateStyleguideWebhooks(styleguideId, webhookId, styleguideWebhookUpdateBody, options);
        const response = await request(this.axios, this.basePath);
        return response;
    }

    /**
     * Update a webhook for the user
     * @summary Update user webhooks
     * @param {string} webhookId Webhook id
     * @param {UserWebhookUpdateBody} userWebhookUpdateBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public async updateUserWebhooks(webhookId: string, userWebhookUpdateBody: UserWebhookUpdateBody, options?: any) : Promise<AxiosResponse<void>> {
        const webhooksApiFp = WebhooksApiFp(this.configuration);
        const request = await webhooksApiFp.updateUserWebhooks(webhookId, userWebhookUpdateBody, options);
        const response = await request(this.axios, this.basePath);
        return response;
    }
}
