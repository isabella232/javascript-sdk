/* tslint:disable */
/* eslint-disable */
/**
 * Zeplin API
 * Access your resources in Zeplin
 *
 * Contact: support@zeplin.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



import globalAxios, { AxiosPromise, AxiosInstance, AxiosResponse } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ErrorResponse } from '../models';
// @ts-ignore
import { TokenCreateBody, transformTokenCreateBodyToJSON } from '../models';
// @ts-ignore
import { TokenResponse, transformJSONToTokenResponse } from '../models';
/**
 * AuthorizationApi - axios parameter creator
 * @export
 */
export const AuthorizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Users are redirected to web app to authenticate themselves and authorize the app with `client_id` to act on behalf of themselves.
         * @summary Authorization endpoint
         * @param {string} responseType Only &#x60;code&#x60; flow is supported
         * @param {string} clientId Identifier of the Zeplin app requesting user authentication
         * @param {string} redirectUri User is redirected to this endpoint after authorization
         * @param {string} [state] RECOMMENDED. An opaque value used by the client to maintain state between the request and callback.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oAuthAuthorize: (
            responseType: string, 
            clientId: string, 
            redirectUri: string, 
            state?: string, 
            codeChallenge?: string, 
            codeChallengeMethod?: string, 
            options: any = {}
        ): RequestArgs => {
            // verify required parameter 'responseType' is not null or undefined
            assertParamExists('oAuthAuthorize', 'responseType', responseType)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('oAuthAuthorize', 'clientId', clientId)
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('oAuthAuthorize', 'redirectUri', redirectUri)
            const localVarPath = `/v1/oauth/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (responseType !== undefined) {
                localVarQueryParameter['response_type'] = responseType;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (codeChallenge !== undefined) {
                localVarQueryParameter['code_challenge'] = codeChallenge;
                localVarQueryParameter['code_challenge_method'] = 'S256';
            }

            if (codeChallengeMethod !== undefined) {
                localVarQueryParameter['code_challenge_method'] = codeChallengeMethod;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If `grant_type` is given as `authorization_code`; handles code flow. If `grant_type` is given as `refresh_token` handles refresh token flow.
         * @summary Access token endpoint
         * @param {TokenCreateBody} tokenCreateBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oAuthPostToken: (tokenCreateBody: TokenCreateBody, options: any = {}): RequestArgs => {
            // verify required parameter 'tokenCreateBody' is not null or undefined
            assertParamExists('oAuthPostToken', 'tokenCreateBody', tokenCreateBody)
            const localVarPath = `/v1/oauth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};

            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformTokenCreateBodyToJSON(tokenCreateBody), localVarRequestOptions, configuration);

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorizationApi - functional programming interface
 * @export
 */
export const AuthorizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthorizationApiAxiosParamCreator(configuration)
    return {
        /**
         * If `grant_type` is given as `authorization_code`; handles code flow. If `grant_type` is given as `refresh_token` handles refresh token flow.
         * @summary Access token endpoint
         * @param {TokenCreateBody} tokenCreateBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oAuthPostToken(tokenCreateBody: TokenCreateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oAuthPostToken(tokenCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Search parameters for getAuthorizeUrl operation in AuthorizationApi.
 * @export
 * @interface AuthorizationApiGetAuthorizationUrlSearchParams
 */
export interface AuthorizationApiGetAuthorizationUrlSearchParams {
    /**
     * Identifier of the Zeplin app requesting user authentication
     * @type {string}
     * @memberof AuthorizationApiGetAuthorizationUrlSearchParams
     */
    readonly clientId: string

    /**
     * User is redirected to this endpoint after authorization
     * @type {string}
     * @memberof AuthorizationApiGetAuthorizationUrlSearchParams
     */
    readonly redirectUri: string

    /**
     * RECOMMENDED. An opaque value used by the client to maintain state between the request and callback.
     * @type {string}
     * @memberof AuthorizationApiGetAuthorizationUrlSearchParams
     */
    readonly state?: string

    /**
     * RECOMMENDED. A PKCE code challenge derived from the code verifier, to be verified against later.
     * @type {string}
     * @memberof AuthorizationApiGetAuthorizationUrlSearchParams
     */
    readonly codeChallenge?: string

    /**
     * RECOMMENDED. PKCE code verifier transformation method.
     * @type {string}
     * @memberof AuthorizationApiGetAuthorizationUrlSearchParams
     */
    readonly codeChallengeMethod?: string
}


/**
 * Search parameters for createToken operation in AuthorizationApi.
 * @export
 * @interface AuthorizationApiCreateTokenParams
 */
export interface AuthorizationApiCreateTokenParams {
    /**
     * Applies when `grant_type` is `authorization_code`. The `code` obtained after `authorization` request
     * @type {string}
     * @memberof AuthorizationApiCreateTokenParams
     */
    code: string;
    /**
     * The URL where users will be redirected after authorization
     * @type {string}
     * @memberof AuthorizationApiCreateTokenParams
     */
    redirectUri: string;
    /**
     * The `client_id` of your Zeplin app
     * @type {string}
     * @memberof AuthorizationApiCreateTokenParams
     */
    clientId: string;
    /**
     * The `client_secret` of your Zeplin app
     * @type {string}
     * @memberof AuthorizationApiCreateTokenParams
     */
    clientSecret?: string;
    /**
     * A cryptographically random string that is used to correlate the authorization request to the token request
     * @type {string}
     * @memberof AuthorizationApiCreateTokenParams
     */
    codeVerifier?: string;
}


/**
 * Search parameters for refreshToken operation in AuthorizationApi.
 * @export
 * @interface AuthorizationApiRefreshTokenParams
 */
export interface AuthorizationApiRefreshTokenParams {
    /**
     * The `refresh_token` you obtained while generating the access token in the first place
     * @type {string}
     * @memberof AuthorizationApiRefreshTokenParams
     */
    refreshToken: string;
    /**
     * The `client_id` of your Zeplin app
     * @type {string}
     * @memberof AuthorizationApiRefreshTokenParams
     */
    clientId: string;
    /**
     * The `client_secret` of your Zeplin app
     * @type {string}
     * @memberof AuthorizationApiRefreshTokenParams
     */
    clientSecret?: string;
    /**
     * A cryptographically random string that is used to correlate the authorization request to the token request
     * @type {string}
     * @memberof AuthorizationApiRefreshTokenParams
     */
    codeVerifier?: string;
}



/**
 * AuthorizationApi - object-oriented interface
 * @export
 * @class AuthorizationApi
 * @extends {BaseAPI}
 */
export class AuthorizationApi extends BaseAPI {

    /**
     * Users are redirected to web app to authenticate themselves and authorize the app with `client_id` to act on behalf of themselves.
     * @summary Authorization endpoint
     * @param {AuthorizationApiGetAuthorizationUrlSearchParams} searchParams Search parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public getAuthorizationUrl(searchParams: AuthorizationApiGetAuthorizationUrlSearchParams, options?: any): string {
        const paramCreator = AuthorizationApiAxiosParamCreator(this.configuration);
        const params = paramCreator.oAuthAuthorize(
            "code", 
            searchParams.clientId, 
            searchParams.redirectUri, 
            searchParams.state, 
            searchParams.codeChallenge, 
            searchParams.codeChallengeMethod, 
            options
        );
        return this.axios.getUri({
            ...params.options,
            url: this.basePath + params.url
        });
    }


    /**
     * Handles code flow
     * @summary Access token endpoint
     * @param {AuthorizationApiCreateTokenParams} params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public async createToken(params: AuthorizationApiCreateTokenParams, options?: any): Promise<AxiosResponse<TokenResponse>> {
        const authorizationApiFp = AuthorizationApiFp(this.configuration);
        const request = await authorizationApiFp.oAuthPostToken(
            {
                ...params,
                grantType: "authorization_code"
            },
            options
        );
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToTokenResponse(response.data)
        };
    }


    /**
     * Handles refresh token flow
     * @summary Access token endpoint
     * @param {AuthorizationApiCreateTokenParams} params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public async refreshToken(params: AuthorizationApiRefreshTokenParams, options?: any): Promise<AxiosResponse<TokenResponse>> {
        const authorizationApiFp = AuthorizationApiFp(this.configuration);
        const request = await authorizationApiFp.oAuthPostToken(
            {
                ...params,
                grantType: "refresh_token"
            },
            options
        );
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToTokenResponse(response.data)
        };
    }
}
