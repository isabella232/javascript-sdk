/* tslint:disable */
/* eslint-disable */
/**
 * Zeplin API
 * Access your resources in Zeplin
 *
 * Contact: support@zeplin.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosResponse } from 'axios';
import FormData from 'form-data';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import {
    ErrorResponse,
    transformErrorResponseToJSON,
    transformJSONToErrorResponse
} from '../models';
// @ts-ignore
import {
    Notification,
    transformNotificationToJSON,
    transformJSONToNotification
} from '../models';
// @ts-ignore
import {
    NotificationTypeEnum,
    transformNotificationTypeEnumToJSON,
    transformJSONToNotificationTypeEnum
} from '../models';
// @ts-ignore
import {
    NotificationUpdateBody,
    transformNotificationUpdateBodyToJSON,
    transformJSONToNotificationUpdateBody
} from '../models';
/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a notification by id
         * @summary Get a notification of user
         * @param {string} notificationId Notification id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotification: async (notificationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('getUserNotification', 'notificationId', notificationId)
            const localVarPath = `/v1/users/me/notifications/{notification_id}`
                .replace(`{${"notification_id"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all notifications of the user
         * @summary Get user notifications
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {boolean} [isRead] Whether the notification is read or not
         * @param {Set<NotificationTypeEnum>} [type] Filter by type  **Note:** Please prefer multiple parameter instances over comma-separated values.  Example: &#x60;?type&#x3D;project.extension&amp;type&#x3D;styleguide.extension&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications: async (limit?: number, offset?: number, isRead?: boolean, type?: Set<NotificationTypeEnum>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/me/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (isRead !== undefined) {
                localVarQueryParameter['is_read'] = isRead;
            }

            if (type) {
                localVarQueryParameter['type'] = Array.from(type);
            }

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a notification for the user
         * @summary Update user notification
         * @param {string} notificationId Notification id
         * @param {NotificationUpdateBody} notificationUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNotification: async (notificationId: string, notificationUpdateBody: NotificationUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('updateUserNotification', 'notificationId', notificationId)
            // verify required parameter 'notificationUpdateBody' is not null or undefined
            assertParamExists('updateUserNotification', 'notificationUpdateBody', notificationUpdateBody)
            const localVarPath = `/v1/users/me/notifications/{notification_id}`
                .replace(`{${"notification_id"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformNotificationUpdateBodyToJSON(notificationUpdateBody), localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates all user notifications unless `type` or `id` parameter is given.  If `type` parameter is provided, updates notifications with matching type.  Similarly, updates notifications with matching identifiers if `id` parameter is provided.  ☝️ `type` and `id` should not be used in conjunction. 
         * @summary Bulk update user notifications
         * @param {NotificationUpdateBody} notificationUpdateBody 
         * @param {Set<NotificationTypeEnum>} [type] Filter by type  **Note:** Please prefer multiple parameter instances over comma-separated values.  Example: &#x60;?type&#x3D;project.extension&amp;type&#x3D;styleguide.extension&#x60; 
         * @param {Array<string>} [id] Filter by id  **Note:** Please prefer multiple parameter instances over comma-separated values.  Example: &#x60;?id&#x3D;5fbe387f8c72ef23659fb500&amp;id&#x3D;602281f4783f72fccc045484&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNotifications: async (notificationUpdateBody: NotificationUpdateBody, type?: Set<NotificationTypeEnum>, id?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationUpdateBody' is not null or undefined
            assertParamExists('updateUserNotifications', 'notificationUpdateBody', notificationUpdateBody)
            const localVarPath = `/v1/users/me/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type) {
                localVarQueryParameter['type'] = Array.from(type);
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformNotificationUpdateBodyToJSON(notificationUpdateBody), localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a notification by id
         * @summary Get a notification of user
         * @param {string} notificationId Notification id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserNotification(notificationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserNotification(notificationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all notifications of the user
         * @summary Get user notifications
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {boolean} [isRead] Whether the notification is read or not
         * @param {Set<NotificationTypeEnum>} [type] Filter by type  **Note:** Please prefer multiple parameter instances over comma-separated values.  Example: &#x60;?type&#x3D;project.extension&amp;type&#x3D;styleguide.extension&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserNotifications(limit?: number, offset?: number, isRead?: boolean, type?: Set<NotificationTypeEnum>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserNotifications(limit, offset, isRead, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a notification for the user
         * @summary Update user notification
         * @param {string} notificationId Notification id
         * @param {NotificationUpdateBody} notificationUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserNotification(notificationId: string, notificationUpdateBody: NotificationUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserNotification(notificationId, notificationUpdateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates all user notifications unless `type` or `id` parameter is given.  If `type` parameter is provided, updates notifications with matching type.  Similarly, updates notifications with matching identifiers if `id` parameter is provided.  ☝️ `type` and `id` should not be used in conjunction. 
         * @summary Bulk update user notifications
         * @param {NotificationUpdateBody} notificationUpdateBody 
         * @param {Set<NotificationTypeEnum>} [type] Filter by type  **Note:** Please prefer multiple parameter instances over comma-separated values.  Example: &#x60;?type&#x3D;project.extension&amp;type&#x3D;styleguide.extension&#x60; 
         * @param {Array<string>} [id] Filter by id  **Note:** Please prefer multiple parameter instances over comma-separated values.  Example: &#x60;?id&#x3D;5fbe387f8c72ef23659fb500&amp;id&#x3D;602281f4783f72fccc045484&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserNotifications(notificationUpdateBody: NotificationUpdateBody, type?: Set<NotificationTypeEnum>, id?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserNotifications(notificationUpdateBody, type, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};



/**
 * Search parameters for getUserNotifications operation in NotificationsApi.
 * @export
 * @interface NotificationsApiGetUserNotificationsSearchParams
 */
export interface NotificationsApiGetUserNotificationsSearchParams {
    /**
     * Pagination limit
     * @type {number}
     * @memberof NotificationsApiGetUserNotificationsSearchParams
     */
    readonly limit?: number;

    /**
     * Pagination offset
     * @type {number}
     * @memberof NotificationsApiGetUserNotificationsSearchParams
     */
    readonly offset?: number;

    /**
     * Whether the notification is read or not
     * @type {boolean}
     * @memberof NotificationsApiGetUserNotificationsSearchParams
     */
    readonly isRead?: boolean;

    /**
     * Filter by type  **Note:** Please prefer multiple parameter instances over comma-separated values.  Example: &#x60;?type&#x3D;project.extension&amp;type&#x3D;styleguide.extension&#x60; 
     * @type {Set<NotificationTypeEnum>}
     * @memberof NotificationsApiGetUserNotificationsSearchParams
     */
    readonly type?: Set<NotificationTypeEnum>;
}


/**
 * Search parameters for updateUserNotifications operation in NotificationsApi.
 * @export
 * @interface NotificationsApiUpdateUserNotificationsSearchParams
 */
export interface NotificationsApiUpdateUserNotificationsSearchParams {
    /**
     * Filter by type  **Note:** Please prefer multiple parameter instances over comma-separated values.  Example: &#x60;?type&#x3D;project.extension&amp;type&#x3D;styleguide.extension&#x60; 
     * @type {Set<NotificationTypeEnum>}
     * @memberof NotificationsApiUpdateUserNotificationsSearchParams
     */
    readonly type?: Set<NotificationTypeEnum>;

    /**
     * Filter by id  **Note:** Please prefer multiple parameter instances over comma-separated values.  Example: &#x60;?id&#x3D;5fbe387f8c72ef23659fb500&amp;id&#x3D;602281f4783f72fccc045484&#x60; 
     * @type {Array<string>}
     * @memberof NotificationsApiUpdateUserNotificationsSearchParams
     */
    readonly id?: Array<string>;
}


/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * Get a notification by id
     * @summary Get a notification of user
     * @param {string} notificationId Notification id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public async getUserNotification(notificationId: string, options?: any) : Promise<AxiosResponse<Notification>> {
        const notificationsApiFp = NotificationsApiFp(this.configuration);
        const request = await notificationsApiFp.getUserNotification(notificationId, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToNotification(response.data)
        };
    }

    /**
     * List all notifications of the user
     * @summary Get user notifications
     * @param {NotificationsApiGetUserNotificationsSearchParams} [searchParams] Search parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public async getUserNotifications(searchParams: NotificationsApiGetUserNotificationsSearchParams = {}, options?: any) : Promise<AxiosResponse<Array<Notification>>> {
        const notificationsApiFp = NotificationsApiFp(this.configuration);
        const request = await notificationsApiFp.getUserNotifications(searchParams.limit, searchParams.offset, searchParams.isRead, searchParams.type, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: response.data.map(transformJSONToNotification)
        };
    }

    /**
     * Update a notification for the user
     * @summary Update user notification
     * @param {string} notificationId Notification id
     * @param {NotificationUpdateBody} notificationUpdateBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public async updateUserNotification(notificationId: string, notificationUpdateBody: NotificationUpdateBody, options?: any) : Promise<AxiosResponse<void>> {
        const notificationsApiFp = NotificationsApiFp(this.configuration);
        const request = await notificationsApiFp.updateUserNotification(notificationId, notificationUpdateBody, options);
        const response = await request(this.axios, this.basePath);
        return response;
    }

    /**
     * Updates all user notifications unless `type` or `id` parameter is given.  If `type` parameter is provided, updates notifications with matching type.  Similarly, updates notifications with matching identifiers if `id` parameter is provided.  ☝️ `type` and `id` should not be used in conjunction. 
     * @summary Bulk update user notifications
     * @param {NotificationUpdateBody} notificationUpdateBody
     * @param {NotificationsApiUpdateUserNotificationsSearchParams} [searchParams] Search parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public async updateUserNotifications(notificationUpdateBody: NotificationUpdateBody, searchParams: NotificationsApiUpdateUserNotificationsSearchParams = {}, options?: any) : Promise<AxiosResponse<void>> {
        const notificationsApiFp = NotificationsApiFp(this.configuration);
        const request = await notificationsApiFp.updateUserNotifications(notificationUpdateBody, searchParams.type, searchParams.id, options);
        const response = await request(this.axios, this.basePath);
        return response;
    }
}
